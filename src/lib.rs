use keynergy::Layout;

pub struct XkbLayout {
    pub content: String,
}

pub enum XkbError {
    NoStandardFormat,
}

impl XkbLayout {
    pub fn from(l: &Layout) -> Result<Self, XkbError> {
        let standard = match &l.formats.standard {
            Some(m) => m,
            None => return Err(XkbError::NoStandardFormat),
        };
        let angle = match &l.formats.angle {
            Some(m) => format!(
                "partial
xkb_symbols \"angle\" {{
    // the standard layout with Angle Mod applied

    include \"{}\"

    name[Group1] = \"{} (with Angle Mod)\";
 
{}
}};",
                &l.name.replace(" ", "_").to_ascii_lowercase(),
                &l.name,
                create_xkb_keys(m.home_row, &m.matrix)
            ),
            None => "".to_string(),
        };
        Ok(Self {
            content: format!(
                "// Standard {} layout - created by {}
// File auto-generated by Keynergy layoutexport (github.com/keynergy/layoutexport)

default partial
xkb_symbols \"basic\" {{
    include \"us(basic)\"

    name[Group1] = \"{}\";

{}
}};
{}",
                l.name,
                l.author,
                l.name,
                create_xkb_keys(standard.home_row, &standard.matrix),
                angle,
            ),
        })
    }
}

fn create_xkb_keys(homerow: u8, m: &Vec<Vec<char>>) -> String {
    let mut keys: Vec<String> = Vec::new();
    let first_row = match m.len() {
    	1 => 2,
    	2 => 1,
    	3 => 1,
    	4 => 0,
    	_ => panic!("can't handle this row count")
    };
    for (y, row) in m.iter().enumerate() {
        for (x, k) in row.iter().enumerate() {
            let row_sign = ["AE", "AD", "AC", "AB"][first_row+y];
            let key = match *k {
                ';' => "semicolon".to_string(),
                '\'' => "apostrophe".to_string(),
                ',' => "comma".to_string(),
                '.' => "period".to_string(),
                '/' => "slash".to_string(),
                '[' => "bracketleft".to_string(),
                ']' => "bracketright".to_string(),
                '-' => "minus".to_string(),
                _ => k.to_string(),
            };
            let uppercase = match *k {
                ';' => "colon".to_string(),
                '\'' => "quotedbl".to_string(),
                ',' => "less".to_string(),
                '.' => "greater".to_string(),
                '/' => "question".to_string(),
                '[' => "braceleft".to_string(),
                ']' => "braceright".to_string(),
                '-' => "underscore".to_string(),
                _ => k.to_ascii_uppercase().to_string(),
            };
            keys.push(format!(
                "    key <{}{:02}> {{[ {}, {} ]}};",
                row_sign,
                x + 1,
                key,
                uppercase
            ));
        }
    }
    keys.join("\n")
}
